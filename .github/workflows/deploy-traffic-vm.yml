name: Deploy Traffic Infrastructure

on:
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/deploy-traffic-vm.yml'
      - 'cmd/**'
      - 'internal/**'
  workflow_dispatch:
    inputs:
      vm_name:
        description: 'Name for the Traffic VM'
        required: false
        default: 'traffic-vm'
      machine_type:
        description: 'Machine type for the VM'
        required: false
        default: 'e2-micro'

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  SERVICE: simple-traffic
  REGION: us-central1
  ZONE: us-central1-a

jobs:
  build-and-deploy-container:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Google Auth
      id: auth
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    - name: Configure Docker for Artifact Registry
      run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

    - name: Build and Push to Artifact Registry
      run: |-
        docker build -t ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE }}/${{ env.SERVICE }}:${{ github.sha }} ./
        docker push ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE }}/${{ env.SERVICE }}:${{ github.sha }}


  deploy-traffic-vm:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Google Auth
      id: auth
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    - name: Delete and Create Traffic VM
      run: |
        VM_NAME="${{ github.event.inputs.vm_name || 'traffic-vm' }}"
        MACHINE_TYPE="${{ github.event.inputs.machine_type || 'e2-micro' }}"
        
        # Always delete existing instance if it exists
        if gcloud compute instances describe $VM_NAME --zone=${{ env.ZONE }} >/dev/null 2>&1; then
          echo "Deleting existing instance"
          gcloud compute instances delete $VM_NAME --zone=${{ env.ZONE }} --quiet || echo "Delete failed, instance may already be gone"
          
          # Wait for deletion to complete
          echo "Waiting for deletion to complete..."
          while gcloud compute instances describe $VM_NAME --zone=${{ env.ZONE }} >/dev/null 2>&1; do
            echo "Still deleting..."
            sleep 5
          done
          echo "Instance deleted successfully"
        else
          echo "No existing instance found, proceeding with creation"
        fi
        
        # Create VM
        echo "Creating new Traffic VM: $VM_NAME"
        gcloud compute instances create $VM_NAME \
          --zone=${{ env.ZONE }} \
          --machine-type=$MACHINE_TYPE \
          --image-family=ubuntu-2204-lts \
          --image-project=ubuntu-os-cloud \
          --boot-disk-size=50GB \
          --boot-disk-type=pd-standard \
          --tags=traffic-vm,http-server,https-server \
          --scopes=https://www.googleapis.com/auth/cloud-platform
        
        # Wait and verify VM is ready
        echo "Waiting for VM to be ready..."
        for i in {1..12}; do
          if gcloud compute ssh $VM_NAME --zone=${{ env.ZONE }} --command="echo 'VM ready'" >/dev/null 2>&1; then
            echo "VM is ready and SSH accessible"
            break
          fi
          echo "Waiting for SSH... ($i/12)"
          sleep 10
        done
        
        # Final check
        if ! gcloud compute ssh $VM_NAME --zone=${{ env.ZONE }} --command="echo 'VM ready'" >/dev/null 2>&1; then
          echo "Error: VM not ready after 2 minutes"
          exit 1
        fi

    - name: Install Dependencies on VM
      run: |
        VM_NAME="${{ github.event.inputs.vm_name || 'traffic-vm' }}"
        
        # Wait for VM to be ready
        sleep 30
        
        # Install all dependencies
        gcloud compute ssh $VM_NAME --zone=${{ env.ZONE }} --command="
          # Update system
          sudo apt-get update
          sudo apt-get install -y python3 python3-pip curl wget jq docker.io
          
          # Start Docker
          sudo systemctl start docker
          sudo systemctl enable docker
          
          # Install Node.js 18.x
          curl -fsSL https://deb.nodesource.com/setup_18.x | sudo bash -
          sudo apt-get install -y nodejs
          
          # Install mitmproxy
          sudo pip3 install mitmproxy
          
          # Install Claude Code CLI
          echo 'Installing Claude Code CLI...'
          sudo npm install -g @anthropic-ai/claude-code
          
          # Add npm global bin to PATH
          NPM_GLOBAL_BIN=\$(npm config get prefix)/bin
          echo 'export PATH=\$PATH:'\$NPM_GLOBAL_BIN | sudo tee -a /etc/profile
          sudo ln -sf \$NPM_GLOBAL_BIN/claude /usr/local/bin/claude
        "

    - name: Setup Traffic Proxy Certificates
      run: |
        VM_NAME="${{ github.event.inputs.vm_name || 'traffic-vm' }}"
        
        # Setup traffic proxy on VM
        gcloud compute ssh $VM_NAME --zone=${{ env.ZONE }} --command="
          # Create traffic user
          sudo useradd -m -s /bin/bash traffic || echo 'User already exists'
          
          # Create directories for logs and certificates
          sudo mkdir -p /opt/traffic/{logs,certs}
          sudo chown -R traffic:traffic /opt/traffic

          # Generate traffic proxy certificates
          sudo -u traffic mitmproxy --set confdir=/opt/traffic/certs &
          TRAFFIC_PID=\$!

          # Wait for certificates to be generated (max 10 minutes)
          for i in {1..60}; do
              if [ -f '/opt/traffic/certs/mitmproxy-ca-cert.pem' ]; then
                  echo 'Certificates generated successfully'
                  kill \$TRAFFIC_PID || true
                  break
              fi
              echo 'Waiting for certificates... ('\$i'/60)'
              sleep 10
          done

          # Check if we timed out
          if [ ! -f '/opt/traffic/certs/mitmproxy-ca-cert.pem' ]; then
              echo 'Error: Certificate generation timed out after 10 minutes'
              exit 1
          fi

          # Install traffic CA certificate to system trust store
          sudo cp /opt/traffic/certs/mitmproxy-ca-cert.pem /usr/local/share/ca-certificates/mitmproxy-ca-cert.crt
          sudo update-ca-certificates
        "

    - name: Create startup script
      run: |
        cat > startup-script.sh << 'EOF'
        #!/bin/bash
        set -e

        # Create traffic proxy script
        cat > /opt/traffic/traffic_script.py << 'SCRIPT_EOF'
        import json
        import datetime
        from mitmproxy import http

        def request(flow: http.HTTPFlow) -> None:
            log_entry = {
                "timestamp": datetime.datetime.now().isoformat(),
                "type": "request",
                "method": flow.request.method,
                "url": flow.request.pretty_url,
                "headers": dict(flow.request.headers),
                "content": flow.request.content.decode('utf-8', errors='ignore') if flow.request.content else ""
            }
            
            with open("/opt/traffic/logs/traffic.jsonl", "a") as f:
                f.write(json.dumps(log_entry) + "\n")

        def response(flow: http.HTTPFlow) -> None:
            log_entry = {
                "timestamp": datetime.datetime.now().isoformat(),
                "type": "response",
                "status_code": flow.response.status_code,
                "url": flow.request.pretty_url,
                "headers": dict(flow.response.headers),
                "content": flow.response.content.decode('utf-8', errors='ignore') if flow.response.content else ""
            }
            
            with open("/opt/traffic/logs/traffic.jsonl", "a") as f:
                f.write(json.dumps(log_entry) + "\n")
        SCRIPT_EOF

        chown traffic:traffic /opt/traffic/traffic_script.py

        # Create iptables setup script
        cat > /opt/traffic/setup-iptables.sh << 'IPTABLES_EOF'
        #!/bin/bash
        echo "Setting up iptables rules for transparent interception..."
        # Exclude traffic user from redirection to prevent loops
        sudo iptables -t nat -A OUTPUT -m owner --uid-owner traffic -j RETURN
        # Redirect HTTP traffic to mitmproxy
        sudo iptables -t nat -A OUTPUT -p tcp --dport 80 -j REDIRECT --to-port 8080
        # Redirect HTTPS traffic to mitmproxy
        sudo iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDIRECT --to-port 8080
        echo "iptables rules configured for transparent mode"
        IPTABLES_EOF
        
        chmod +x /opt/traffic/setup-iptables.sh
        
        # Create cleanup script to clear iptables rules
        cat > /opt/traffic/clear-iptables.sh << 'CLEANUP_EOF'
        #!/bin/bash
        echo "Clearing iptables OUTPUT rules..."
        sudo iptables -t nat -F OUTPUT
        echo "iptables OUTPUT rules cleared - traffic interception disabled"
        CLEANUP_EOF
        
        chmod +x /opt/traffic/clear-iptables.sh
        
        # Create startup helper script for manual use
        cat > /opt/traffic/start-proxy.sh << 'SCRIPT_EOF'
        #!/bin/bash
        echo "Starting traffic proxy on port 8080..."
        echo "Log file: /opt/traffic/logs/traffic.jsonl"
        echo "To stop: Press Ctrl+C"
        echo ""
        sudo -u traffic mitmdump -s /opt/traffic/traffic_script.py --set confdir=/opt/traffic/certs --listen-port 8080 --mode transparent
        SCRIPT_EOF
        
        chmod +x /opt/traffic/start-proxy.sh

        # Create log cleanup script
        cat > /opt/traffic/cleanup-logs.sh << 'CLEANUP_LOGS_EOF'
        #!/bin/bash
        echo "Clearing traffic logs..."
        sudo -u traffic rm -f /opt/traffic/logs/traffic.jsonl
        sudo -u traffic touch /opt/traffic/logs/traffic.jsonl
        echo "Traffic logs cleared"
        CLEANUP_LOGS_EOF
        
        chmod +x /opt/traffic/cleanup-logs.sh

        # Configure NODE_EXTRA_CA_CERTS for Node.js applications
        echo "NODE_EXTRA_CA_CERTS=/opt/traffic/certs/mitmproxy-ca-cert.pem" >> /etc/environment
        
        echo "Traffic VM setup completed successfully"
        
        # Auto-start traffic proxy on boot
        echo "Setting up iptables and starting traffic proxy..."
        /opt/traffic/setup-iptables.sh
        nohup /opt/traffic/start-proxy.sh > /opt/traffic/logs/startup.log 2>&1 &
        echo "Traffic proxy started automatically"
        
        EOF

        chmod +x startup-script.sh


    - name: Create firewall rules
      run: |
        # Allow SSH access
        gcloud compute firewall-rules create allow-ssh-traffic \
          --allow tcp:22 \
          --source-ranges 0.0.0.0/0 \
          --target-tags traffic-vm \
          --description "Allow SSH to Traffic VM" || echo "Firewall rule already exists"
        
        # Allow HTTP/HTTPS for testing and Go service
        gcloud compute firewall-rules create allow-http-https-traffic \
          --allow tcp:80,tcp:443,tcp:8080,tcp:8081 \
          --source-ranges 0.0.0.0/0 \
          --target-tags traffic-vm \
          --description "Allow HTTP/HTTPS and Go service to Traffic VM" || echo "Firewall rule already exists"

    - name: Deploy Container to Traffic VM
      run: |-
        VM_NAME="${{ github.event.inputs.vm_name || 'traffic-vm' }}"
        
        # Wait for VM to be fully ready
        echo "Waiting for VM to be ready..."
        sleep 30
        
        # Deploy container to the traffic VM
        echo "Deploying Go service container to $VM_NAME"
        gcloud compute ssh $VM_NAME --zone=${{ env.ZONE }} --command="
          # Install Docker if not present
          if ! command -v docker &> /dev/null; then
            echo 'Installing Docker...'
            sudo apt-get update
            sudo apt-get install -y docker.io
            sudo systemctl start docker
            sudo systemctl enable docker
            sudo usermod -aG docker \$USER
          fi
          
          # Configure Docker for Artifact Registry
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev
          
          # Stop any existing container
          sudo docker stop simple-traffic || true
          sudo docker rm simple-traffic || true
          
          # Pull and run new container
          sudo docker pull ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE }}/${{ env.SERVICE }}:${{ github.sha }}
          sudo docker run -d --name simple-traffic --restart=always -p 8081:8080 \
            ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE }}/${{ env.SERVICE }}:${{ github.sha }}
          
          echo 'Container deployed successfully'
        "


    - name: Cleanup
      run: rm -f startup-script.sh